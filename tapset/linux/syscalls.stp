
# mbind ______________________________________________________
# long sys_mbind(unsigned long start,
#	unsigned long len,
#	unsigned long mode,
#	unsigned long __user *nmask,
#	unsigned long maxnode,
#	unsigned flags)
#
# long compat_sys_mbind(compat_ulong_t start,
#	compat_ulong_t len,
#	compat_ulong_t mode,
#	compat_ulong_t __user *nmask,
#	compat_ulong_t maxnode,
#	compat_ulong_t flags)
#
probe syscall.mbind = __syscall.mbind ?,
                      kernel.function("compat_sys_mbind").call ?
{
	name = "mbind"
	start = $start
	mode = __int32($mode)
	mode_str = _mempolicy_mode_str(mode)
	nmask_uaddr = $nmask
	flags = __uint32($flags)
	flags_str = _mempolicy_flags_str(flags)
	len = @__compat_ulong($len)
	maxnode = @__compat_ulong($maxnode)
	argstr = sprintf("%p, %u, %s, %p, %u, %s", start, len,
	                 mode_str, nmask_uaddr, maxnode, flags_str)
}
probe __syscall.mbind = kernel.function("sys_mbind").call
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}
probe syscall.mbind.return = __syscall.mbind.return ?,
                             kernel.function("compat_sys_mbind").return ?
{
	name = "mbind"
	retstr = return_str(1, $return)
}
probe __syscall.mbind.return = kernel.function("sys_mbind").return
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}

# membarrier _______________________________________________________
# SYSCALL_DEFINE2(membarrier, int, cmd, int, flags)
probe syscall.membarrier = kernel.function("sys_membarrier").call ?
{
	name = "membarrier"
	cmd = __int32($cmd)
	cmd_str = _membarrier_cmd_str(cmd)
	flags = __int32($flags)
	argstr = sprintf("%s, %d", _membarrier_cmd_str(cmd),
			 __int32($flags))
}
probe syscall.membarrier.return = kernel.function("sys_membarrier").return ?
{
	name = "membarrier"
	retstr = return_str(1, $return)
}

# memfd_create _____________________________________________________
# long sys_memfd_create (const char __user* uname, unsigned int flags)
probe syscall.memfd_create = kernel.function("sys_memfd_create").call ?
{
	name = "memfd_create"
	uname = user_string_quoted($uname)
	flags = $flags
	flags_str = _mfd_flags_str($flags)
	argstr = sprintf("%s, %s", user_string_quoted($uname), flags_str)
}
probe syscall.memfd_create.return = kernel.function("sys_memfd_create").return ?
{
	name = "memfd_create"
	retstr = return_str(1, $return)
}

# migrate_pages ____________________________________________________
# long sys_migrate_pages(pid_t pid, unsigned long maxnode,
#		const unsigned long __user *old_nodes,
#		const unsigned long __user *new_nodes)
probe syscall.migrate_pages = __syscall.migrate_pages ?,
                              kernel.function("compat_sys_migrate_pages").call ?
{
	name = "migrate_pages"
	pid = __int32($pid)
	old_nodes = $old_nodes
	new_nodes = $new_nodes
	maxnode = @__compat_ulong($maxnode)
	argstr = sprintf("%d, %u, %p, %p", pid, maxnode, old_nodes, new_nodes)
}
probe __syscall.migrate_pages = kernel.function("sys_migrate_pages").call
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}
probe syscall.migrate_pages.return = __syscall.migrate_pages.return ?,
                                     kernel.function("compat_sys_migrate_pages").return ?
{
	name = "migrate_pages"
	retstr = return_str(1, $return)
}
probe __syscall.migrate_pages.return = kernel.function("sys_migrate_pages").return
{
%( arch == "powerpc" %?
	@__syscall_gate_compat_simple
%)
}

# mincore ____________________________________________________
# long sys_mincore(unsigned long start, size_t len, unsigned char __user * vec)
#
probe syscall.mincore = kernel.function("sys_mincore").call ?
{
	name = "mincore"
	start = $start
	length = __ulong($len)
	vec_uaddr = $vec
	argstr = sprintf("%p, %u, %p", start, length, vec_uaddr)
}
probe syscall.mincore.return = kernel.function("sys_mincore").return ?
{
	name = "mincore"
	retstr = return_str(1, $return)
}

# mkdir ______________________________________________________
# long sys_mkdir(const char __user * pathname, int mode)
probe syscall.mkdir = kernel.function("sys_mkdir").call
{
	name = "mkdir"
	pathname_uaddr = $pathname
	pathname = user_string_quoted($pathname)
	mode = __uint32($mode)
	argstr = sprintf("%s, %#o", user_string_quoted($pathname),
			 __uint32($mode))
}
probe syscall.mkdir.return = kernel.function("sys_mkdir").return
{
	name = "mkdir"
	retstr = return_str(1, $return)
}

# mkdirat ____________________________________________________
# new function with 2.6.16
# long sys_mkdirat(int dfd, const char __user *pathname, int mode)
probe syscall.mkdirat = kernel.function("sys_mkdirat").call ?
{
	@__syscall_compat_gate(@const("__NR_mkdirat"), @const("__NR_compat_mkdirat"))
	name = "mkdirat"
	dirfd = __int32($dfd)
	dirfd_str = _dfd_str(__int32($dfd))
	pathname = user_string_quoted($pathname)
	mode = __uint32($mode)
	argstr = sprintf("%s, %s, %#o", _dfd_str(__int32($dfd)),
			 user_string_quoted($pathname), __uint32($mode))
}
probe syscall.mkdirat.return = kernel.function("sys_mkdirat").return ?
{
	@__syscall_compat_gate(@const("__NR_mkdirat"), @const("__NR_compat_mkdirat"))
	name = "mkdirat"
	retstr = return_str(1, $return)
}

# mknod ______________________________________________________
# long sys_mknod(const char __user * filename, int mode, unsigned dev)
probe syscall.mknod = kernel.function("sys_mknod").call
{
	name = "mknod"
	pathname = user_string_quoted($filename)
	mode = __uint32($mode)
	dev = __uint32($dev)
	argstr = sprintf("%s, %s, %u", pathname, _mknod_mode_str(mode), dev)
}

probe syscall.mknod.return = kernel.function("sys_mknod").return
{
	name = "mknod"
	retstr = return_str(1, $return)
}

# mknodat ____________________________________________________
# new function with 2.6.16
# long sys_mknodat(int dfd, const char __user *filename,
#	int mode, unsigned dev)
probe syscall.mknodat = kernel.function("sys_mknodat").call ?
{
	@__syscall_compat_gate(@const("__NR_mknodat"), @const("__NR_compat_mknodat"))
	name = "mknodat"
	dirfd = __int32($dfd)
	dirfd_str = _dfd_str(dirfd)
	pathname = user_string_quoted($filename)
	mode = __uint32($mode)
	mode_str = _mknod_mode_str(mode)
	dev = __uint32($dev)
	argstr = sprintf("%s, %s, %s, %u",
		dirfd_str, pathname, mode_str, dev)
}
probe syscall.mknodat.return = kernel.function("sys_mknodat").return ?
{
	@__syscall_compat_gate(@const("__NR_mknodat"), @const("__NR_compat_mknodat"))
	name = "mknodat"
	retstr = return_str(1, $return)
}

# mlock ______________________________________________________
#
# long sys_mlock(unsigned long start, size_t len)
#
probe syscall.mlock = kernel.function("sys_mlock").call ?
{
	name = "mlock"
	addr = __ulong($start)
	len = __ulong($len)
	argstr = sprintf("%p, %u", addr, len)
}
probe syscall.mlock.return = kernel.function("sys_mlock").return ?
{
	name = "mlock"
	retstr = return_str(1, $return)
}

# mlock2 _____________________________________________________
#
# long sys_mlock2(unsigned long start, size_t len, int flags)
#
probe syscall.mlock2 = kernel.function("sys_mlock2").call ?
{
	name = "mlock2"
	addr = __ulong($start)
	len = __ulong($len)
	flags = __int32($flags)
	flags_str = _stp_mlock2_str(__int32($flags))
	argstr = sprintf("%p, %u, %s", addr, len, flags_str)
}
probe syscall.mlock2.return = kernel.function("sys_mlock2").return ?
{
	name = "mlock2"
	retstr = return_str(1, $return)
}

# mlockall ___________________________________________________
#
# long sys_mlockall(int flags)
#
probe syscall.mlockall = kernel.function("sys_mlockall").call ?
{
	name = "mlockall"
	flags = __int32($flags)
	argstr = _mlockall_flags_str(flags)
}
probe syscall.mlockall.return = kernel.function("sys_mlockall").return ?
{
	name = "mlockall"
	retstr = return_str(1, $return)
}

# modify_ldt _________________________________________________
# int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)
#
probe syscall.modify_ldt = kernel.function("sys_modify_ldt").call ?
{
	name = "modify_ldt"
	func = __int32($func)
	ptr_uaddr = $ptr
	bytecount = __ulong($bytecount)
	argstr = sprintf("%d, %p, %u", $func, $ptr, __ulong($bytecount))
}
probe syscall.modify_ldt.return = kernel.function("sys_modify_ldt").return ?
{
	name = "modify_ldt"
	retstr = return_str(1, $return)
}

# move_pages ____________________________________________________
# long sys_move_pages(pid_t pid, unsigned long nr_pages,
#			const void __user * __user *pages,
#			const int __user *nodes,
#			int __user *status,
#			int flags)
#
# long compat_sys_move_pages(pid_t pid, unsigned long nr_pages,
#                compat_uptr_t __user *pages32,
#                const int __user *nodes,
#                int __user *status,
#                int flags)
#
probe syscall.move_pages = __syscall.move_pages ?,
                           kernel.function("compat_sys_move_pages").call ?
{
	name = "move_pages"
	pages = @choose_defined($pages32, $pages)
	pid = __int32($pid)
	nodes = $nodes
	status = $status
	flags = __int32($flags)
	flags_str = _mempolicy_flags_str(flags)
	nr_pages = @__compat_ulong($nr_pages)
	argstr = sprintf("%d, %u, %p, %p, %p, %s", pid, nr_pages, pages,
	                 nodes, status, flags_str)
}
probe __syscall.move_pages = kernel.function("sys_move_pages").call
{
	@__syscall_gate(@const("__NR_move_pages"))
}
probe syscall.move_pages.return = __syscall.move_pages.return ?,
                                  kernel.function("compat_sys_move_pages").return ?
{
	name = "move_pages"
	retstr = return_str(1, $return)
}
probe __syscall.move_pages.return = kernel.function("sys_move_pages").return
{
	@__syscall_gate(@const("__NR_move_pages"))
}

# mount ______________________________________________________
# long sys_mount(char __user * dev_name,
# 		char __user * dir_name,
# 		char __user * type,
# 		unsigned long flags,
# 		void __user * data)
# long compat_sys_mount(char __user * dev_name,
#		char __user * dir_name,
#		char __user * type,
#		unsigned long flags,
#		void __user * data)
probe syscall.mount = kernel.function("compat_sys_mount").call ?,
                      kernel.function("sys_mount").call
{
	name = "mount"
	source = user_string_quoted($dev_name)
	target = user_string_quoted($dir_name)
	filesystemtype = user_string_quoted($type)
	mountflags = $flags
	mountflags_str = _mountflags_str($flags)
	data = user_string_n_quoted($data, syscall_string_trunc)
	argstr = sprintf("%s, %s, %s, %s, %s",
		user_string_quoted($dev_name),
		user_string_quoted($dir_name),
		user_string_quoted($type),
		mountflags_str, data)
}
probe syscall.mount.return = kernel.function("compat_sys_mount").return ?,
                             kernel.function("sys_mount").return
{
	name = "mount"
	retstr = return_str(1, $return)
}

%( kernel_v >= "2.6.33" %?
# In newer kernels (2.6.33+), all the sys_mmap() variants are just 
# wrappers around sys_mmap_pgoff(), which is in arch-generic code.
#
# long sys_mmap_pgoff(unsigned long addr, unsigned long len,
#		unsigned long prot, unsigned long flags,
#		unsigned long fd, unsigned long pgoff)
probe syscall.mmap2 = kernel.function("sys_mmap_pgoff") ?
{
	name = "mmap2"
	start = $addr
	length = __ulong($len)
	prot = $prot
	flags = $flags
	# Although the kernel gets an unsigned long fd, on the
	# user-side it is a signed int.  Fix this.
	fd = __int32($fd)
	# $pgoff is the number of pages. Convert this back into a
	# number of bytes.
	pgoffset = $pgoff * @const("PAGE_SIZE")
	argstr = sprintf("%p, %u, %s, %s, %d, %d", $addr, __ulong($len),
		_mprotect_prot_str($prot), _mmap_flags($flags),
		__int32($fd), pgoffset)
}
probe syscall.mmap2.return = kernel.function("sys_mmap_pgoff").return ?
{
        name = "mmap2"
        retstr = return_str(2, $return)
}
%)

# mprotect ___________________________________________________
# long sys_mprotect(unsigned long start, size_t len, unsigned long prot)
#
probe syscall.mprotect = kernel.function("sys_mprotect").call ?
{
	name = "mprotect"
	addr = $start
	len = $len
	prot = $prot
	prot_str = _mprotect_prot_str($prot)
	argstr = sprintf("%p, %d, %s", $start, $len, _mprotect_prot_str($prot))
}
probe syscall.mprotect.return = kernel.function("sys_mprotect").return ?
{
	name = "mprotect"
	retstr = return_str(1, $return)
}

# mq_getsetattr ______________________________________________
# long sys_mq_getsetattr(mqd_t mqdes,
#                  const struct mq_attr __user *u_mqstat,
#                  struct mq_attr __user *u_omqstat)
# long compat_sys_mq_getsetattr(mqd_t mqdes,
#			const struct compat_mq_attr __user *u_mqstat,
#			struct compat_mq_attr __user *u_omqstat)
#
probe syscall.mq_getsetattr =
        __syscall.mq_getsetattr,
        kernel.function("compat_sys_mq_getsetattr").call ?
{
	name = "mq_getsetattr"
	mqdes = __int32($mqdes)
	u_mqstat_uaddr = $u_mqstat
	u_omqstat_uaddr = $u_omqstat
	argstr = sprintf("%d, %p, %p", mqdes, u_mqstat_uaddr, u_omqstat_uaddr)
}
probe __syscall.mq_getsetattr = kernel.function("sys_mq_getsetattr").call
{
        @__syscall_gate(@const("__NR_mq_getsetattr"))
}
probe syscall.mq_getsetattr.return =
        __syscall.mq_getsetattr.return,
        kernel.function("compat_sys_mq_getsetattr").return ?
{
	name = "mq_getsetattr"
	retstr = return_str(1, $return)
}
probe __syscall.mq_getsetattr.return = kernel.function("sys_mq_getsetattr").return
{
        @__syscall_gate(@const("__NR_mq_getsetattr"))
}

# mq_notify __________________________________________________
# long sys_mq_notify(mqd_t mqdes, const struct sigevent __user *u_notification)
# long compat_sys_mq_notify(mqd_t mqdes, const struct compat_sigevent __user *u_notification)
#
probe syscall.mq_notify =
        __syscall.mq_notify,
        kernel.function("compat_sys_mq_notify").call ?
{
	name = "mq_notify"
	mqdes = __int32($mqdes)
	notification_uaddr = $u_notification
	argstr = sprintf("%d, %p", mqdes, $u_notification)
}
probe __syscall.mq_notify = kernel.function("sys_mq_notify").call
{
        @__syscall_gate(@const("__NR_mq_notify"))
}
probe syscall.mq_notify.return =
        __syscall.mq_notify.return,
        kernel.function("compat_sys_mq_notify").return ?
{
	name = "mq_notify"
	retstr = return_str(1, $return)
}
probe __syscall.mq_notify.return = kernel.function("sys_mq_notify").return
{
        @__syscall_gate(@const("__NR_mq_notify"))
}

# mq_open ____________________________________________________
# long  sys_mq_open(const char __user *u_name,
#             int oflag,
#             mode_t mode,
#             struct mq_attr __user *u_attr)
# long compat_sys_mq_open(const char __user *u_name,
#			int oflag, compat_mode_t mode,
#			struct compat_mq_attr __user *u_attr)
#
probe syscall.mq_open = __syscall.mq_open,
                        kernel.function("compat_sys_mq_open").call ?
{
	name = "mq_open"
	name_uaddr = $u_name
	filename = user_string_quoted($u_name)
	u_attr_uaddr = $u_attr
	oflag = __int32($oflag)
	mode = (@__compat_task ? __ushort($mode) : __uint32($mode))
	if (oflag & 64)
		argstr = sprintf("%s, %s, %#o, %p", user_string_quoted($u_name),
			_sys_open_flag_str(oflag), mode, $u_attr)
	else
		argstr = sprintf("%s, %s", user_string_quoted($u_name), _sys_open_flag_str(oflag))
}

probe __syscall.mq_open = kernel.function("sys_mq_open").call
{
	@__syscall_gate_compat_simple
}
probe syscall.mq_open.return =
        __syscall.mq_open.return,
        kernel.function("compat_sys_mq_open").return ?
{
	name = "mq_open"
	retstr = return_str(1, $return)
}
probe __syscall.mq_open.return = kernel.function("sys_mq_open").return
{
        @__syscall_gate(@const("__NR_mq_open"))
}

# mq_timedreceive ____________________________________________
# ssize_t sys_mq_timedreceive(mqd_t mqdes,
#                     char __user *u_msg_ptr,
#                     size_t msg_len,
#                     unsigned int __user *u_msg_prio,
#                     const struct timespec __user *u_abs_timeout)
# ssize_t compat_sys_mq_timedreceive(mqd_t mqdes,
#			char __user *u_msg_ptr,
#			size_t msg_len, unsigned int __user *u_msg_prio,
#			const struct compat_timespec __user *u_abs_timeout)
#
probe syscall.mq_timedreceive =
	__syscall.mq_timedreceive ?,
	kernel.function("compat_sys_mq_timedreceive").call ?
{
	name = "mq_timedreceive"
	mqdes = __int32($mqdes)
	msg_ptr_uaddr = $u_msg_ptr
	msg_prio_uaddr = $u_msg_prio
	abs_timeout_uaddr = $u_abs_timeout
%( CONFIG_64BIT == "y" %?
	msg_len = @__compat_ulong($msg_len)
%:
	msg_len = __uint32($msg_len)
%)
	argstr = sprintf("%d, %p, %u, %p, %p", mqdes, $u_msg_ptr, msg_len,
		$u_msg_prio, $u_abs_timeout)
}
probe __syscall.mq_timedreceive = kernel.function("sys_mq_timedreceive").call
{
        @__syscall_gate(@const("__NR_mq_timedreceive"))
}
probe syscall.mq_timedreceive.return =
        __syscall.mq_timedreceive.return,
        kernel.function("compat_sys_mq_timedreceive").return ?
{
	name = "mq_timedreceive"
	retstr = return_str(1, $return)
}
probe __syscall.mq_timedreceive.return = kernel.function("sys_mq_timedreceive").return
{
	@__syscall_gate_compat_simple
}

# mq_timedsend _______________________________________________
# long sys_mq_timedsend(mqd_t mqdes,
#                  const char __user *u_msg_ptr,
#                  size_t msg_len,
#                  unsigned int msg_prio,
#                  const struct timespec __user *u_abs_timeout)
#  long compat_sys_mq_timedsend(mqd_t mqdes,
#			const char __user *u_msg_ptr,
#			size_t msg_len, unsigned int msg_prio,
#			const struct compat_timespec __user *u_abs_timeout)
#
probe syscall.mq_timedsend =
	__syscall.mq_timedsend,
	kernel.function("compat_sys_mq_timedsend").call ?
{
	name = "mq_timedsend"
	mqdes = __int32($mqdes)
	msg_ptr_uaddr = $u_msg_ptr
	msg_prio = __uint32($msg_prio)
	abs_timeout_uaddr = $u_abs_timeout
%( CONFIG_64BIT == "y" %?
	msg_len = @__compat_ulong($msg_len)
%:
	msg_len = __uint32($msg_len)
%)
	argstr = sprintf("%d, %p, %u, %u, %p", mqdes, $u_msg_ptr, msg_len,
		__uint32($msg_prio), $u_abs_timeout)
}
probe __syscall.mq_timedsend = kernel.function("sys_mq_timedsend").call
{
        @__syscall_gate(@const("__NR_mq_timedsend"))
}
probe syscall.mq_timedsend.return =
        __syscall.mq_timedsend.return,
        kernel.function("compat_sys_mq_timedsend").return ?
{
	name = "mq_timedsend"
	retstr = return_str(1, $return)
}
probe __syscall.mq_timedsend.return = kernel.function("sys_mq_timedsend").return
{
	@__syscall_gate_compat_simple
}

# mq_unlink __________________________________________________
# long sys_mq_unlink(const char __user *u_name)
#
probe syscall.mq_unlink = kernel.function("sys_mq_unlink").call ?
{
	name = "mq_unlink"
	u_name_uaddr = $u_name
	u_name = user_string_quoted($u_name)
	argstr = user_string_quoted($u_name)
}
probe syscall.mq_unlink.return = kernel.function("sys_mq_unlink").return ?
{
	name = "mq_unlink"
	retstr = return_str(1, $return)
}

# mremap _____________________________________________________
# unsigned long sys_mremap(unsigned long addr,
#            unsigned long old_len,
#            unsigned long new_len,
#            unsigned long flags,
#            unsigned long new_addr)
#
probe syscall.mremap = kernel.function("ia64_mremap").call ?,
                       kernel.function("sys_mremap").call ?
{
	name = "mremap"
	old_address = $addr
	old_size = $old_len
	new_size = $new_len
	flags = $flags
	new_address = $new_addr
	argstr = sprintf("%p, %d, %d, %s, %p", $addr, $old_len, $new_len,
		_mremap_flags($flags), $new_addr)
}
probe syscall.mremap.return = kernel.function("ia64_mremap").return ?,
                              kernel.function("sys_mremap").return ?
{
	name = "mremap"
	retstr = return_str(2, $return)
}

# msgctl _____________________________________________________
# long sys_msgctl (int msqid, int cmd, struct msqid_ds __user *buf)
#
probe syscall.msgctl = kernel.function("sys_msgctl").call ?
{
	@__syscall_gate2(@const("__NR_msgctl"), @const("__NR_ipc"))
	name = "msgctl"
	msqid = __int32($msqid)
	cmd = __int32($cmd)
	cmd_str = _stp_msgctl_cmd_str(__int32($cmd))
	buf_uaddr = $buf
	argstr = sprintf("%d, %s, %p", __int32($msqid),
			 _stp_msgctl_cmd_str(__int32($cmd)), $buf)
}
probe syscall.msgctl.return = kernel.function("sys_msgctl").return ?
{
	@__syscall_gate2(@const("__NR_msgctl"), @const("__NR_ipc"))
	name = "msgctl"
	retstr = return_str(1, $return)
}
# compat_sys_msgctl ________________________________________
#
# long compat_sys_msgctl(int first, int second, void __user *uptr)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgctl = __syscall.compat_msgctl ?,
      __syscall.compat_ipc.msgctl ?
{
	name = "msgctl"
	cmd_str = _stp_msgctl_cmd_str(cmd)
	argstr = sprintf("%d, %s, %p", msqid, _stp_msgctl_cmd_str(cmd),
			 buf_uaddr)
}
probe __syscall.compat_msgctl = kernel.function("compat_sys_msgctl").call ?
{
	msqid = __int32($first)
	cmd = __int32($second)
	buf_uaddr = $uptr
}
probe __syscall.compat_ipc.msgctl = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGCTL")) next;
	msqid = __int32($first)
	cmd = __int32($second)
	buf_uaddr = $ptr
}
probe syscall.compat_sys_msgctl.return =
	kernel.function("compat_sys_msgctl").return ?,
	__syscall.compat_ipc.msgctl.return ?
{
	name = "msgctl"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgctl.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGCTL")) next;
}

# msgget _____________________________________________________
# long sys_msgget (key_t key, int msgflg)
#
probe syscall.msgget = kernel.function("sys_msgget").call ?
{
	name = "msgget"
	key = __int32($key)
	key_str = _stp_msgget_key_str(__int32($key))
	msgflg = __int32($msgflg)
	msgflg_str = __sem_flags(__int32($msgflg))
	argstr = sprintf("%s, %s", _stp_msgget_key_str(__int32($key)),
			 __sem_flags(__int32($msgflg)))
}
probe syscall.msgget.return = kernel.function("sys_msgget").return ?
{
	name = "msgget"
	retstr = return_str(1, $return)
}

# msgrcv _____________________________________________________
# long sys_msgrcv (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             long msgtyp,
#             int msgflg)
#
probe syscall.msgrcv = kernel.function("sys_msgrcv").call ?
{
	name = "msgrcv"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgtyp = $msgtyp
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %d, %s", __int32($msqid), $msgp,
			 __ulong($msgsz), $msgtyp,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgrcv.return = kernel.function("sys_msgrcv").return ?
{
	name = "msgrcv"
	retstr = return_str(1, $return)
}
# compat_sys_msgrcv ________________________________________
#
# long compat_sys_msgrcv(int first, int second, int msgtyp, int third,
#			int version, void __user *uptr)
# COMPAT_SYSCALL_DEFINE5(msgrcv, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, long, msgtyp, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgrcv = __syscall.compat_msgrcv ?,
	__syscall.compat_ipc.msgrcv ?
{
	name = "msgrcv"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %d, %s", msqid, msgp_uaddr, msgsz,
			 msgtyp, _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgrcv = kernel.function("compat_sys_msgrcv").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	if (@defined($version)) {
		msgp_uaddr = _stp_compat_msgrcv_msgbuf($uptr, $version)
		msgtyp = _stp_compat_msgrcv_msgtyp($uptr, $version, $msgtyp)
	}
	else {
		msgp_uaddr = $msgp
		msgtyp = __int32($msgtyp)
	}
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgrcv = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGRCV")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)

	# __version isn't quite correct (it should be shifted down 16
	# bits), but all we really need is zero/non-zero.
	__version = $call & 0xffff0000
	msgp_uaddr = _stp_compat_msgrcv_msgbuf($ptr, __version)
	msgtyp = _stp_compat_msgrcv_msgtyp($ptr, __version, $fifth)
}
probe syscall.compat_sys_msgrcv.return =
	kernel.function("compat_sys_msgrcv").return ?,
	__syscall.compat_ipc.msgrcv.return ?
{
	name = "msgrcv"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgrcv.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGRCV")) next;
}

# msgsnd _____________________________________________________
# long sys_msgsnd (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             int msgflg)
#
probe syscall.msgsnd = kernel.function("sys_msgsnd").call ?
{
	name = "msgsnd"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %s", __int32($msqid), $msgp, msgsz,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgsnd.return = kernel.function("sys_msgsnd").return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
# compat_sys_msgsnd ________________________________________
#
# long compat_sys_msgsnd(int first, int second, int third, void __user *uptr)
# COMPAT_SYSCALL_DEFINE4(msgsnd, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgsnd = __syscall.compat_msgsnd ?,
      __syscall.compat_ipc.msgsnd ?
{
	name = "msgsnd"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %s", msqid, msgp_uaddr, msgsz,
			 _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgsnd = kernel.function("compat_sys_msgsnd").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	msgp_uaddr = @choose_defined($msgp, $uptr)
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgsnd = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGSND")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)
	msgp_uaddr = $ptr
}
probe syscall.compat_sys_msgsnd.return =
	kernel.function("compat_sys_msgsnd").return ?,
	__syscall.compat_ipc.msgsnd.return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgsnd.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGSND")) next;
}

# msync ______________________________________________________
# long sys_msync(unsigned long start, size_t len, int flags)
probe syscall.msync = kernel.function("sys_msync").call ?
{
	name = "msync"
	start = $start
	length = __ulong($len)
	flags = __int32($flags)
	argstr = sprintf("%p, %u, %s", start, length, _msync_flag_str(flags))
}
probe syscall.msync.return = kernel.function("sys_msync").return ?
{
	name = "msync"
	retstr = return_str(1, $return)
}

# munlock ____________________________________________________
# long sys_munlock(unsigned long start, size_t len)
probe syscall.munlock = kernel.function("sys_munlock").call ?
{
	name = "munlock"
	addr = $start
	len = $len
	argstr = sprintf("%p, %d", addr, len)
}
probe syscall.munlock.return = kernel.function("sys_munlock").return ?
{
	name = "munlock"
	retstr = return_str(1, $return)
}

# munlockall _________________________________________________
# long sys_munlockall(void)
probe syscall.munlockall = kernel.function("sys_munlockall").call ?
{
	name = "munlockall"
	argstr = ""
}
probe syscall.munlockall.return = kernel.function("sys_munlockall").return ?
{
	name = "munlockall"
	retstr = return_str(1, $return)
}

# munmap _____________________________________________________
# long sys_munmap(unsigned long addr, size_t len)
probe syscall.munmap = kernel.function("sys_munmap").call
{
	name = "munmap"
	start = $addr
	length = __ulong($len)
	argstr = sprintf("%p, %u", start, length)
}
probe syscall.munmap.return = kernel.function("sys_munmap").return
{
	name = "munmap"
	retstr = return_str(1, $return)
}


# msgget _____________________________________________________
# long sys_msgget (key_t key, int msgflg)
#
probe syscall.msgget = kernel.function("sys_msgget").call ?
{
	name = "msgget"
	key = __int32($key)
	key_str = _stp_msgget_key_str(__int32($key))
	msgflg = __int32($msgflg)
	msgflg_str = __sem_flags(__int32($msgflg))
	argstr = sprintf("%s, %s", _stp_msgget_key_str(__int32($key)),
			 __sem_flags(__int32($msgflg)))
}
probe syscall.msgget.return = kernel.function("sys_msgget").return ?
{
	name = "msgget"
	retstr = return_str(1, $return)
}

# msgrcv _____________________________________________________
# long sys_msgrcv (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             long msgtyp,
#             int msgflg)
#
probe syscall.msgrcv = kernel.function("sys_msgrcv").call ?
{
	name = "msgrcv"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgtyp = $msgtyp
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %d, %s", __int32($msqid), $msgp,
			 __ulong($msgsz), $msgtyp,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgrcv.return = kernel.function("sys_msgrcv").return ?
{
	name = "msgrcv"
	retstr = return_str(1, $return)
}
# compat_sys_msgrcv ________________________________________
#
# long compat_sys_msgrcv(int first, int second, int msgtyp, int third,
#			int version, void __user *uptr)
# COMPAT_SYSCALL_DEFINE5(msgrcv, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, long, msgtyp, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgrcv = __syscall.compat_msgrcv ?,
	__syscall.compat_ipc.msgrcv ?
{
	name = "msgrcv"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %d, %s", msqid, msgp_uaddr, msgsz,
			 msgtyp, _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgrcv = kernel.function("compat_sys_msgrcv").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	if (@defined($version)) {
		msgp_uaddr = _stp_compat_msgrcv_msgbuf($uptr, $version)
		msgtyp = _stp_compat_msgrcv_msgtyp($uptr, $version, $msgtyp)
	}
	else {
		msgp_uaddr = $msgp
		msgtyp = __int32($msgtyp)
	}
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgrcv = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGRCV")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)

	# __version isn't quite correct (it should be shifted down 16
	# bits), but all we really need is zero/non-zero.
	__version = $call & 0xffff0000
	msgp_uaddr = _stp_compat_msgrcv_msgbuf($ptr, __version)
	msgtyp = _stp_compat_msgrcv_msgtyp($ptr, __version, $fifth)
}
probe syscall.compat_sys_msgrcv.return =
	kernel.function("compat_sys_msgrcv").return ?,
	__syscall.compat_ipc.msgrcv.return ?
{
	name = "msgrcv"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgrcv.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGRCV")) next;
}

# msgsnd _____________________________________________________
# long sys_msgsnd (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             int msgflg)
#
probe syscall.msgsnd = kernel.function("sys_msgsnd").call ?
{
	name = "msgsnd"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %s", __int32($msqid), $msgp, msgsz,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgsnd.return = kernel.function("sys_msgsnd").return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
# compat_sys_msgsnd ________________________________________
#
# long compat_sys_msgsnd(int first, int second, int third, void __user *uptr)
# COMPAT_SYSCALL_DEFINE4(msgsnd, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgsnd = __syscall.compat_msgsnd ?,
      __syscall.compat_ipc.msgsnd ?
{
	name = "msgsnd"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %s", msqid, msgp_uaddr, msgsz,
			 _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgsnd = kernel.function("compat_sys_msgsnd").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	msgp_uaddr = @choose_defined($msgp, $uptr)
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgsnd = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGSND")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)
	msgp_uaddr = $ptr
}
probe syscall.compat_sys_msgsnd.return =
	kernel.function("compat_sys_msgsnd").return ?,
	__syscall.compat_ipc.msgsnd.return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgsnd.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGSND")) next;
}

# msync ______________________________________________________
# long sys_msync(unsigned long start, size_t len, int flags)
probe syscall.msync = kernel.function("sys_msync").call ?
{
	name = "msync"
	start = $start
	length = __ulong($len)
	flags = __int32($flags)
	argstr = sprintf("%p, %u, %s", start, length, _msync_flag_str(flags))
}
probe syscall.msync.return = kernel.function("sys_msync").return ?
{
	name = "msync"
	retstr = return_str(1, $return)
}

# munlock ____________________________________________________
# long sys_munlock(unsigned long start, size_t len)
probe syscall.munlock = kernel.function("sys_munlock").call ?
{
	name = "munlock"
	addr = $start
	len = $len
	argstr = sprintf("%p, %d", addr, len)
}
probe syscall.munlock.return = kernel.function("sys_munlock").return ?
{
	name = "munlock"
	retstr = return_str(1, $return)
}

# munlockall _________________________________________________
# long sys_munlockall(void)
probe syscall.munlockall = kernel.function("sys_munlockall").call ?
{
	name = "munlockall"
	argstr = ""
}
probe syscall.munlockall.return = kernel.function("sys_munlockall").return ?
{
	name = "munlockall"
	retstr = return_str(1, $return)
}

# munmap _____________________________________________________
# long sys_munmap(unsigned long addr, size_t len)
probe syscall.munmap = kernel.function("sys_munmap").call
{
	name = "munmap"
	start = $addr
	length = __ulong($len)
	argstr = sprintf("%p, %u", start, length)
}
probe syscall.munmap.return = kernel.function("sys_munmap").return
{
	name = "munmap"
	retstr = return_str(1, $return)
}

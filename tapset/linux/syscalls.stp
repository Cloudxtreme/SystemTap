
# msgsnd _____________________________________________________
# long sys_msgsnd (int msqid,
#             struct msgbuf __user *msgp,
#             size_t msgsz,
#             int msgflg)
#
probe syscall.msgsnd = kernel.function("sys_msgsnd").call ?
{
	name = "msgsnd"
	msqid = __int32($msqid)
	msgp_uaddr = $msgp
	msgsz = __ulong($msgsz)
	msgflg = __int32($msgflg)
	msgflg_str = _stp_msgflg_str(__int32($msgflg))
	argstr = sprintf("%d, %p, %u, %s", __int32($msqid), $msgp, msgsz,
			 _stp_msgflg_str(__int32($msgflg)))
}
probe syscall.msgsnd.return = kernel.function("sys_msgsnd").return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
# compat_sys_msgsnd ________________________________________
#
# long compat_sys_msgsnd(int first, int second, int third, void __user *uptr)
# COMPAT_SYSCALL_DEFINE4(msgsnd, int, msqid, compat_uptr_t, msgp,
#		       compat_ssize_t, msgsz, int, msgflg)
# ifdef CONFIG_ARCH_WANT_OLD_COMPAT_IPC
#  COMPAT_SYSCALL_DEFINE6(ipc, u32, call, int, first, int, second,
#	u32, third, compat_uptr_t, ptr, u32, fifth)
# endif
#
probe syscall.compat_sys_msgsnd = __syscall.compat_msgsnd ?,
      __syscall.compat_ipc.msgsnd ?
{
	name = "msgsnd"
	msgflg_str = _stp_msgflg_str(msgflg)
	argstr = sprintf("%d, %p, %u, %s", msqid, msgp_uaddr, msgsz,
			 _stp_msgflg_str(msgflg))
}
probe __syscall.compat_msgsnd = kernel.function("compat_sys_msgsnd").call ?
{
	msqid = __int32(@choose_defined($msqid, $first))
	msgp_uaddr = @choose_defined($msgp, $uptr)
	msgsz = __uint32(@choose_defined($msgsz, $second))
	msgflg = __int32(@choose_defined($msgflg, $third))
}
probe __syscall.compat_ipc.msgsnd = kernel.function("compat_sys_ipc").call ?
{
	if (($call & 0xffff) != @const("MSGSND")) next;
	msqid = __int32($first)
	msgsz = __uint32($second)
	msgflg = __int32($third)
	msgp_uaddr = $ptr
}
probe syscall.compat_sys_msgsnd.return =
	kernel.function("compat_sys_msgsnd").return ?,
	__syscall.compat_ipc.msgsnd.return ?
{
	name = "msgsnd"
	retstr = return_str(1, $return)
}
probe __syscall.compat_ipc.msgsnd.return =
	kernel.function("compat_sys_ipc").return ?
{
	if ((@entry($call) & 0xffff) != @const("MSGSND")) next;
}

# msync ______________________________________________________
# long sys_msync(unsigned long start, size_t len, int flags)
probe syscall.msync = kernel.function("sys_msync").call ?
{
	name = "msync"
	start = $start
	length = __ulong($len)
	flags = __int32($flags)
	argstr = sprintf("%p, %u, %s", start, length, _msync_flag_str(flags))
}
probe syscall.msync.return = kernel.function("sys_msync").return ?
{
	name = "msync"
	retstr = return_str(1, $return)
}

# munlock ____________________________________________________
# long sys_munlock(unsigned long start, size_t len)
probe syscall.munlock = kernel.function("sys_munlock").call ?
{
	name = "munlock"
	addr = $start
	len = $len
	argstr = sprintf("%p, %d", addr, len)
}
probe syscall.munlock.return = kernel.function("sys_munlock").return ?
{
	name = "munlock"
	retstr = return_str(1, $return)
}

# munlockall _________________________________________________
# long sys_munlockall(void)
probe syscall.munlockall = kernel.function("sys_munlockall").call ?
{
	name = "munlockall"
	argstr = ""
}
probe syscall.munlockall.return = kernel.function("sys_munlockall").return ?
{
	name = "munlockall"
	retstr = return_str(1, $return)
}

# munmap _____________________________________________________
# long sys_munmap(unsigned long addr, size_t len)
probe syscall.munmap = kernel.function("sys_munmap").call
{
	name = "munmap"
	start = $addr
	length = __ulong($len)
	argstr = sprintf("%p, %u", start, length)
}
probe syscall.munmap.return = kernel.function("sys_munmap").return
{
	name = "munmap"
	retstr = return_str(1, $return)
}

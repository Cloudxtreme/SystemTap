// python 3 tapset
// Copyright (C) 2016 Red Hat Inc.
//
// This file is part of systemtap, and is free software.  You can
// redistribute it and/or modify it under the terms of the GNU General
// Public License (GPL); either version 2, or (at your option) any
// later version.

%{
/*
 * Defines borrowed from object.h.
 */
 
/* These flags are used to determine if a type is a subclass. */
#define Py3_TPFLAGS_LONG_SUBCLASS        (1L<<24)
#define Py3_TPFLAGS_LIST_SUBCLASS        (1L<<25)
#define Py3_TPFLAGS_TUPLE_SUBCLASS       (1L<<26)
#define Py3_TPFLAGS_BYTES_SUBCLASS       (1L<<27)
#define Py3_TPFLAGS_UNICODE_SUBCLASS     (1L<<28)
#define Py3_TPFLAGS_DICT_SUBCLASS        (1L<<29)
#define Py3_TPFLAGS_BASE_EXC_SUBCLASS    (1L<<30)
#define Py3_TPFLAGS_TYPE_SUBCLASS        (1L<<31)
%}

#
# Macros to cast to various python 3 types
#

###########################################
#
# FIXME: We've got a couple of problems with @cast() here.
#
# 1) The first thing in the @cast module list is 'python3'. On some
#    systems, the python3 executable is just named
#    'python'. Systemtap's configure script finds the right name for
#    the python 3 executable, but that information doesn't make it
#    here. This file may need to be generated at systemtap build time
#    (i.e. have a 'python3.stp.in' tapset file that gets turned into
#    'python3.stp').
#
# 2) The 2nd and 3rd items in the @cast module list is 64-bit and
#    32-bit versions of 'libpython3.5m.so'. That is the name of the
#    current version of python 3 library on rawhide systems. On f23
#    systems, the current version of the python3 library is
#    'libpython3.4m.so'. If we could use wildcards in @cast module
#    paths we could work around this problem (see PR20394).
#
###########################################

@define Py3Object(object) %(
    @cast(@object, "PyObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3VarObject(object) %(
    @cast(@object, "PyVarObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3BytesObject(object) %(
    @cast(@object, "PyBytesObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3UnicodeObject(object) %(
    @cast(@object, "PyUnicodeObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3TypeObject(object) %(
    @cast(@object, "PyTypeObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3TupleObject(object) %(
    @cast(@object, "PyTupleObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3ListObject(object) %(
    @cast(@object, "PyListObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3SetObject(object) %(
    @cast(@object, "PySetObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3DictObject(object) %(
    @cast(@object, "PyDictObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3DictEntry(object) %(
    @cast(@object, "PyDictEntry",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3FrameObject(object) %(
    @cast(@object, "PyFrameObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3CodeObject(object) %(
    @cast(@object, "PyCodeObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)

@define Py3ASCIIObject(object) %(
    @cast(@object, "PyASCIIObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3ASCIIObject_Sizeof %(
    @cast_module_sizeof("python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so",
			"PyASCIIObject")
%)

@define Py3CompactUnicodeObject(object) %(
    @cast(@object, "PyCompactUnicodeObject",
	  "python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so")
%)
@define Py3CompactUnicodeObject_Sizeof %(
    @cast_module_sizeof("python3:/usr/lib64/libpython3.5m.so:/usr/lib/libpython3.5m.so",
			"PyCompactUnicodeObject")
%)

#
# Systemtap macros based on C macros in object.h.
#

@define Py3_REFCNT(object) %(
    @Py3Object(@object)->ob_refcnt
%)
@define Py3_TYPE(object) %(
    @Py3Object(@object)->ob_type
%)
@define Py3_SIZE(object) %(
    @Py3VarObject(@object)->ob_size
%)

@define Py3Type_HasFeature(t, f) %(
    ((@t->tp_flags & (@f)) != 0)
%)
@define Py3Type_FastSubclass(t, f) %(
    @Py3Type_HasFeature(@t, @f)
%)

#
# Systemtap macros based on C macros in bytesobject.h.
#

@define Py3Bytes_Check(op) %(
    @Py3Type_FastSubclass(@Py3_TYPE(@op), %{ Py3_TPFLAGS_BYTES_SUBCLASS %})
%)

#
# Systemtap macros based on C macros in unicodeobject.h.
#

@define Py3Unicode_Check(op) %(
    @Py3Type_FastSubclass(@Py3_TYPE(@op), %{ Py3_TPFLAGS_UNICODE_SUBCLASS %})
%)

/* Returns the length of the unicode string. */
@define Py3Unicode_GET_LENGTH(op) %(
    ((@Py3Unicode_Check(@op) && @Py3Unicode_IS_READY(@op))
     ? @Py3ASCIIObject(@op)->length : 0)
%)

@define Py3Unicode_IS_READY(op) %(
    @Py3ASCIIObject(@op)->state->ready
%)

@define Py3Unicode_IS_ASCII(op) %(
    (@Py3Unicode_Check(@op) && @Py3Unicode_IS_READY(@op)
     && @Py3ASCIIObject(@op)->state->ascii)
%)

/* Return true if the string is compact or 0 if not.
   No type checks or Ready calls are performed. */
@define Py3Unicode_IS_COMPACT(op) %(
    (@Py3ASCIIObject(@op)->state->compact)
%)

/* Return a void pointer to the raw unicode buffer. */
@define _Py3Unicode_COMPACT_DATA(op) %(
    (@Py3Unicode_IS_ASCII(@op)
     ? (@op + @Py3ASCIIObject_Sizeof)
     : (@op + @Py3CompactUnicodeObject_Sizeof))
%)
@define _Py3Unicode_NONCOMPACT_DATA(op) %(
    (@Py3UnicodeObject(@op)->data->any)
%)
@define Py3Unicode_DATA(op) %(
    (@Py3Unicode_IS_COMPACT(@op) ? @_Py3Unicode_COMPACT_DATA(@op)
     : @_Py3Unicode_NONCOMPACT_DATA(@op))
%)

#
# Systemtap functions based on C functions in bytesobject.c.
#

private function Py3Bytes_Size:long(object:long)
{
    if (! @Py3Bytes_Check(object)) {
	# NB: python code returns string_getsize(), creating a new
	# string representation of the object, then returning the
	# length of the new string. We can't create new objects here,
	# so we'll just quit.
	warn(sprintf("Py3Bytes_Size called on non-bytes object address 0x%p\n",
		     object))
	return 0
    }
    return @Py3_SIZE(object)
}

#
# Systemtap functions based on C functions in unicodeobject.c.
#

private function Py3Unicode_AsASCIIString:string(object:long)
{
    if (!@Py3Unicode_Check(object)) {
	# NB: python returns value of string_getbuffer() here
	# (basically getting a string representation of any
	# object). We can't create new objects here, so we'll
	# just quit.
	warn(sprintf("Py3Unicode_AsASCIIString called on non-string address 0x%p\n",
		     object))
	return ""
    }
    if (@Py3Unicode_IS_ASCII(object)) {
        try {
	    return user_string_n(@Py3Unicode_DATA(object),
				 @Py3Unicode_GET_LENGTH(object))
	} catch {
	    warn(sprintf("Py3Unicode_AsASCIIString failed on address 0x%p\n",
			 object))
	}
	return ""
    }
    try {
	return text_str(user_string_n(@Py3Unicode_DATA(object),
				      @Py3Unicode_GET_LENGTH(object)))
    } catch {
	warn(sprintf("Py3Unicode_AsASCIIString failed(2) on address 0x%p\n",
		     @Py3Unicode_DATA(object)))
    }
    return ""
}

#
# Systemtap functions based on C functions in codeobject.c.
#

private function Py3Code_Addr2Line:long(code:long, addrq:long)
{
    /*
     * co_lnotab is used to compute the line number from a bytecode
     * index, addrq. See the file Objects/lnotab_notes.txt in the
     * python source for the details of the lnotab representation.
     *
     * We can't treat co_lnotab as a "real" null terminated string,
     * since co_lnotab can have embedded null characters. So, we'll
     * grab it character by character.
     */
    size = Py3Bytes_Size(@Py3CodeObject(code)->co_lnotab) / 2
    co_lnotab_sval = @Py3BytesObject(@Py3CodeObject(code)->co_lnotab)->ob_sval
    line = @Py3CodeObject(code)->co_firstlineno
    addr = 0
    p = 0
    while (--size >= 0) {
    	addr += user_char(co_lnotab_sval + p++)
	if (addr > addrq)
	    break
	    
	line += user_char(co_lnotab_sval + p++)
    }
    return line
}

#
# Systemtap functions based on C functions in frameobject.c.
#

private function Py3Frame_GetLineNumber:long(frame:long)
{
    if (@Py3FrameObject(frame)->f_trace)
	return @Py3FrameObject(frame)->f_lineno
    else
	return Py3Code_Addr2Line(@Py3FrameObject(frame)->f_code,
				 @Py3FrameObject(frame)->f_lasti)
}

/*
 * python3_print_backtrace - Print python backtrace
 *
 * Description: This function is equivalent to
 * print(python3_sprint_backtrace(frame)), except that deeper stack
 * tracing may be supported. 
 *
 * Note that users should call 'python_print_backtrace()', and the
 * translator will call the appropriate python 2 or python 3 function
 * with the correct argument.
 */
function python3_print_backtrace:long(frame:long)
{
    printf("Traceback (most recent call first):\n")
    while (frame != 0) {
	lineno = Py3Frame_GetLineNumber(frame)
	code = @Py3FrameObject(frame)->f_code
	filename = Py3Unicode_AsASCIIString(code->co_filename)
	name = Py3Unicode_AsASCIIString(code->co_name)

	# Quit when we make it back to the HelperSDT module.
	if (isinstr(filename, "/HelperSDT/"))
	    break;

	printf("  File \"%s\", line %d, in %s\n", filename, lineno, name)
	# NB: We'd like to print the source line here as python does,
	# but we can't. Python opens up the file and finds the
	# appropriate line, but we can't really do that when we're in
	# the kernel.

	frame = @Py3FrameObject(frame)->f_back
    }
}

/*
 * python3_sprint_backtrace - Get python backtrace
 * 
 * Description: This function returns a string containing a python
 * backtrace.  Output may be truncated as per maximum string length
 * (MAXSTRINGLEN).
 *
 * Note that users should call 'python_sprint_backtrace()', and the
 * translator will call the appropriate python 2 or python 3 function
 * with the correct argument.
 */
function python3_sprint_backtrace:string(frame:long)
{
    retstr = "Traceback (most recent call first):\n"
    while (frame != 0) {
	lineno = Py3Frame_GetLineNumber(frame)
	code = @Py3FrameObject(frame)->f_code
	filename = Py3Unicode_AsASCIIString(code->co_filename)
	name = Py3Unicode_AsASCIIString(code->co_name)

	# Quit when we make it back to the HelperSDT module.
	if (isinstr(filename, "/HelperSDT/"))
	    break;

	retstr .= sprintf("  File \"%s\", line %d, in %s\n", filename,
			  lineno, name)

	frame = @Py3FrameObject(frame)->f_back
    }
    return retstr
}

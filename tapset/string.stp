/** @addtogroup library
* The library tapset is a collection of standard functions.
* @{
*/

/** @addtogroup library
* @code function strlen:long(s:string) @endcode
* @param s string
* @return Returns the length of the string.
*/
function strlen:long(s:string) %{ /* pure */ /* unprivileged */
        THIS->__retvalue = strlen(THIS->s);
%}

/** @addtogroup library
* @code function substr:string(str:string,start:long,length:long) @endcode
* @param str string
* @param start Starting position. 0 = start of the string
* @param length Length of string to return.
* @return Returns the substring.
*/
function substr:string(str:string,start:long, length:long) %{ /* pure */ /* unprivileged */
	int length = THIS->length >= MAXSTRINGLEN ? MAXSTRINGLEN : THIS->length + 1;
	if (THIS->start >= 0 && length > 0 && THIS->start < strlen(THIS->str))
		strlcpy(THIS->__retvalue, THIS->str + THIS->start, length);
%}

/** @addtogroup library
* @code function stringat:string(str:string, pos:long) @endcode
* @param str string
* @param pos the given position.  0 = start of the string
* @return Returns the char in given position of string.
*/
function stringat:long(str:string, pos:long) %{ /* pure */ /* unprivileged */
	if (THIS->pos >= 0 && THIS->pos < strlen(THIS->str))
		THIS->__retvalue = THIS->str[THIS->pos];
	else
		THIS->__retvalue = 0;
%}

/** @addtogroup library
* @code isinstr:long(s1:string,s2:string) @endcode
* @param s1 string
* @param s2 string
* @return Returns 1 if s2 is in s1. Otherwise 0.
*/
function isinstr:long(s1:string,s2:string) %{ /* pure */ /* unprivileged */
	if (strstr(THIS->s1,THIS->s2) != NULL)
		THIS->__retvalue = 1;
	else
		THIS->__retvalue = 0;
%}

/*
 * text_str()
 *
 * Takes a string, and any ASCII characters that are not printable are
 * replaced by the corresponding escape sequence in the returned
 * string.
 */
function text_str:string(input:string) 
%{ /* pure */ /* unprivileged */
	_stp_text_str(THIS->__retvalue, THIS->input, 0, 0, 0);
%}

function text_strn:string(input:string, len:long, quoted:long)
%{ /* pure */ /* unprivileged */
	_stp_text_str(THIS->__retvalue, THIS->input, THIS->len, THIS->quoted, 0);
%}

/*
 * tokenize - Given a string and a token delimiter,
 *            return the next non-empty token in the string
 *            or blank when no more non-empty tokens are left
 * input  String to tokenize. If NULL, returns the next non-empty token
 *        in the string passed in the previous call to tokenize().
 * delim  Token delimiter. Set of characters that delimit the tokens.
 */
function tokenize:string(input:string, delim:string)
%{ /* unprivileged */
	static char str[MAXSTRINGLEN];
	static char *str_start;
	static char *str_end;
	char *token = NULL;
	char *token_end = NULL;

	if (THIS->input[0]) {
		strncpy(str, THIS->input, MAXSTRINGLEN);
		str_start = &str[0];
		str_end = &str[0] + strlen(str);
	}
	do {
		token = strsep(&str_start, THIS->delim);
	} while (token && !token[0]);
	if (token) {
		token_end = (str_start ? str_start - 1 : str_end);
		memcpy(THIS->__retvalue, token, token_end - token + 1);
	}
%}

/** @addtogroup library
 * @code str_replace:string (prnt_str:string, srch_str:string, rplc_str:string) @endcode
 * @param prnt_str The parent string.
 * @param srch_str The substring which is used to search in the parent string prnt_str.
 * @param rplc_str The substring which is used to replace the searched string srch_str.
 * @return Returns the parent string with substrings replaced. Else returns parent string.
 */
function str_replace:string (prnt_str:string, srch_str:string, rplc_str:string)
%{ /* pure */ /* unprivileged */
	char *ptr = THIS->prnt_str;
	char *ptr_base = THIS->prnt_str;
	int strlen_srch_str = strlen(THIS->srch_str);

	if(strlen_srch_str == 0) {
		strlcat(THIS->__retvalue, ptr_base, MAXSTRINGLEN);
		return;
	}

	while((ptr = strstr(ptr, THIS->srch_str)) != NULL) {

		*ptr = '\0';
		strlcat(THIS->__retvalue, ptr_base, MAXSTRINGLEN);
		strlcat(THIS->__retvalue, THIS->rplc_str, MAXSTRINGLEN);
		ptr = ptr + strlen_srch_str;
		ptr_base = ptr;
	}

	strlcat(THIS->__retvalue, ptr_base, MAXSTRINGLEN);
	return;
%}

/*
 * strtol - Convert a string to a long
 *   str   String to convert
 *   base  The base to use
 */
function strtol:long(str:string, base:long)
%{ /* pure */ /* unprivileged */
	THIS->__retvalue = simple_strtol(THIS->str, NULL, THIS->base);
%}

/** @} */

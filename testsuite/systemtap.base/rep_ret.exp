set test "rep_ret"

# This test is only for i386 and x86_64
# Test 32-on-64 when available
switch -regexp $::tcl_platform(machine) {
    {^i\d86$} { set arches [list "-default"] }
    {^x86_64$} { set arches [list "-m64" "-m32"]}
    default { unsupported "$test"; return }
}

foreach arch $arches {

  set exe ${test}${arch}
  set testexe "[pwd]/[stap_host_testdir]/$exe"

  verbose "testing $exe"

  set test_flags "additional_flags=-g"
  set test_flags "$test_flags additional_flags=-fomit-frame-pointer"

  if {$arch != "-default"} {
    set test_flags "$test_flags additional_flags=$arch"
  }

  set res [target_compile $srcdir/$subdir/$test.c $testexe executable "$test_flags"]
  if { $res != "" } {
    verbose "target_compile $exe failed: $res" 2
    fail "${test}.c compile ${arch}"
    untested "$exe"
    return
  } else {
    pass "${test}.c compile ${arch}"
  }

  if {[installtest_p] && [uprobes_p]} {
    set ok 0
    set bad 0
    set warn 0

    if [is_remote target] {
        remote_download target $testexe "[stap_target_testdir]/$exe"
    }

    set cmd [concat stap [stap_get_board_args] -e {{probe process(@1).function("*") { println(probefunc()) }}} $testexe -c "[stap_target_testdir]/$exe"]
    send_log "cmd = $cmd"
    eval spawn $cmd
    expect {
      -timeout 300
      -re {^main\r\n} { incr ok; exp_continue }
      -re {^rep_ret\r\n} { incr ok; exp_continue }
      -re {^repnz_ret\r\n} { incr ok; exp_continue }
      -re {^WARNING: Number of errors: 0, skipped probes: [^\r\n]*\r\n} { incr warn; exp_continue }
      timeout { fail "$exe (timeout)" }
      eof { }
    }
    wait

    if {$ok == 3 && $bad == 0 && $warn == 0} {
      pass "$exe"
    } else {
      fail "$exe ($ok, $bad, $warn)"
    }
  } else {
    untested "$exe"
  }
  if [is_remote target] {
    remote_exec target "rm [stap_target_testdir]/$exe"
  }
  catch {exec rm -f $testexe}

}

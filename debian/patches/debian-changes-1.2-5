Description: CVE-2010-4170, CVE-2010-4171: staprun module loading/unloading security fixes
Origin: backport, http://sources.redhat.com/git/gitweb.cgi?p=systemtap.git;a=commit;h=b7565b41228bea196cefa3a7d43ab67f8f9152e2
Bug-Debian: http://bugs.debian.org/603946
Author: Ritesh Raj Sarraf <rrs@debian.org>

--- systemtap-1.2.orig/staprun.8.in
+++ systemtap-1.2/staprun.8.in
@@ -198,13 +198,13 @@ structures and potentially private user
 manual page for additional information on safety and security.
 .PP
 To increase system security, only the root user and members of the
-.I stapdev
-group can use
+.I stapdev " and " staprun
+groups can use
 .I staprun
 to insert systemtap modules (or attach to existing ones).
 Members of the
 .I stapusr
-group can use
+groups can use
 .I staprun
 to insert or remove systemtap modules (or attach to existing systemtap modules)
 under the following conditions:
--- systemtap-1.2.orig/Makefile.am
+++ systemtap-1.2/Makefile.am
@@ -172,7 +172,10 @@ stapio_LDADD = -lpthread
 
 
 install-exec-hook:
-	if [ `id -u` -eq 0 ]; then chmod 04111 "$(DESTDIR)$(bindir)/staprun"; fi
+	if [ `id -u` -eq 0 ]; then \
+		getent group stapusr >/dev/null && chgrp stapusr "$(DESTDIR)$(bindir)/staprun"; \
+		chmod 04110 "$(DESTDIR)$(bindir)/staprun"; \
+	fi
 
 # Why the "id -u" condition?  This way, an unprivileged user can run
 # make install, and have "sudo stap ...." or "sudo staprun ...." work later.
--- systemtap-1.2.orig/Makefile.in
+++ systemtap-1.2/Makefile.in
@@ -1991,7 +1991,10 @@ cscope:
 @BUILD_ELFUTILS_TRUE@@BUILD_TRANSLATOR_TRUE@install-exec-local: install-elfutils
 
 install-exec-hook:
-	if [ `id -u` -eq 0 ]; then chmod 04111 "$(DESTDIR)$(bindir)/staprun"; fi
+	if [ `id -u` -eq 0 ]; then \
+		getent group stapusr >/dev/null && chgrp stapusr "$(DESTDIR)$(bindir)/staprun"; \
+		chmod 04110 "$(DESTDIR)$(bindir)/staprun"; \
+	fi
 
 @BUILD_CRASHMOD_TRUE@$(STAPLOG): staplog.c
 @BUILD_CRASHMOD_TRUE@	$(CC) $(staplog_CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -shared -rdynamic \
--- systemtap-1.2.orig/README.security
+++ systemtap-1.2/README.security
@@ -15,7 +15,7 @@ following:
 
  * the root user;
 
- * a member of the 'stapdev' group; or
+ * a member of both 'stapdev' and 'stapusr' groups; or
 
  * a member of the 'stapusr' group.  Members of the stapusr group can
    only use modules located in the /lib/modules/VERSION/systemtap
@@ -23,8 +23,8 @@ following:
    directory must be owned by root and not be world writable.
 
 So, there are two classes of users: systemtap developers (the root user
-and members of the stapdev group) and systemtap users (members of the
-stapusr group).  Systemtap developers can compile and run any
+and members of the stapdev/stapusr groups) and systemtap users (members of
+only the stapusr group).  Systemtap developers can compile and run any
 systemtap script.  Systemtap users can only run "approved"
 pre-compiled modules located in /lib/modules/VERSION/systemtap.
 
--- systemtap-1.2.orig/runtime/staprun/ctl.c
+++ systemtap-1.2/runtime/staprun/ctl.c
@@ -27,6 +27,9 @@ int init_ctl_channel(const char *name, i
 			return -2;
 	}
 
+	if (access(buf, R_OK|W_OK) != 0)
+		return -5;
+
 	control_channel = open(buf, O_RDWR);
 	dbug(2, "Opened %s (%d)\n", buf, control_channel);
 	if (control_channel < 0) {
--- systemtap-1.2.orig/runtime/staprun/staprun.c
+++ systemtap-1.2/runtime/staprun/staprun.c
@@ -115,19 +115,7 @@ static int enable_uprobes(void)
 	if (run_as(0, uid, gid, argv[0], argv) == 0)
 		return 0;
 
-	/*
-	 * TODO: If user can't setresuid to root here, staprun will exit.
-	 * Is there a situation where that would fail but the subsequent
-	 * attempt to insert_module() would succeed?
-	 */
-	dbug(2, "Inserting uprobes module from /lib/modules, if any.\n");
-	i = 0;
-	argv[i++] = "/sbin/modprobe";
-	argv[i++] = "-q";
-	argv[i++] = "uprobes";
-	argv[i] = NULL;
-	if (run_as(0, 0, 0, argv[0], argv) == 0)
-		return 0;
+        /* NB: don't use /sbin/modprobe, without more env. sanitation. */
 
 	/* This module may be signed, so use insert_module to load it.  */
 	snprintf (runtimeko, sizeof(runtimeko), "%s/uprobes/uprobes.ko",
@@ -186,9 +174,16 @@ static int remove_module(const char *nam
 		return 0;
 	}
 
-        /* We could call init_ctl_channel / close_ctl_channel here, as a heuristic
-           to determine whether the module is being used by some other stapio process.
-           However, delete_module() does basically the same thing. */
+        /* We call init_ctl_channel/close_ctl_channel to check whether
+           the module is a systemtap-built one (having the right files),
+           and that it's already unattached (because otherwise it'd EBUSY
+           the opens. */
+        ret = init_ctl_channel (name, 0);
+        if (ret < 0) {
+                err("Error, '%s' is not a zombie systemtap module.\n", name);
+                return ret;
+        }
+        close_ctl_channel ();
 
 	dbug(2, "removing module %s\n", name);
 	STAP_PROBE1(staprun, remove__module, name);
@@ -223,7 +218,7 @@ int init_staprun(void)
                      without first removing the kernel module.  This would block
                      a subsequent rerun attempt.  So here we gingerly try to
                      unload it first. */
-		  int ret = delete_module (modname, O_NONBLOCK);
+                  int ret = remove_module (modname, 0);
 		  err("Retrying, after attempted removal of module %s (rc %d)\n", modname, ret);
 		  /* Then we try an insert a second time.  */
 		  if (insert_stap_module() < 0)

diff -ruN systemtap-0.9.9-old/runtime/sym.c systemtap-0.9.9/runtime/sym.c
--- systemtap-0.9.9-old/runtime/sym.c	2009-08-05 05:53:49.000000000 +0200
+++ systemtap-0.9.9/runtime/sym.c	2009-09-07 11:17:32.910664821 +0200
@@ -259,7 +259,8 @@
 
 		    /* notes end address */
 		    if (!strcmp(m->name, "kernel")) {
-		  	  notes_addr = m->build_id_offset;
+			  notes_addr = _stp_module_relocate("kernel",
+					 "_stext", m->build_id_offset);
 			  base_addr = _stp_module_relocate("kernel",
 							   "_stext", 0);
                     } else {
diff -ruN systemtap-0.9.9-old/translate.cxx systemtap-0.9.9/translate.cxx
--- systemtap-0.9.9-old/translate.cxx	2009-08-05 05:53:49.000000000 +0200
+++ systemtap-0.9.9/translate.cxx	2009-09-07 11:17:32.910664821 +0200
@@ -4879,11 +4879,12 @@
     c->output << ".build_id_len = " << build_id_len << ",\n";
 
     /* XXX: kernel data boot-time relocation works differently from text.
-       This hack disables relocation altogether, but that's not necessarily
+       This hack assumes that offset between _stext and build id
+       stays constant after relocation, but that's not necessarily
        correct either.  We may instead need a relocation basis different
        from _stext, such as __start_notes.  */
     if (modname == "kernel")
-      c->output << ".build_id_offset = 0x" << hex << build_id_vaddr
+      c->output << ".build_id_offset = 0x" << hex << build_id_vaddr - (base + extra_offset)
                 << dec << ",\n";
     else
       c->output << ".build_id_offset = 0x" << hex
